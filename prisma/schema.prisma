generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// =======================
// ENUMS
// =======================

enum QuestionType {
  MULTIPLE_CHOICE
  MULTI_SELECT
  TRUE_FALSE
  FILL_BLANK
  FILL_BLANK_CLUE
}

enum EvaluationType {
  AUTO
  MANUAL
}

// =======================
// AUTH MODELS
// =======================

model User {
  id            String    @id @default(uuid())
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  role          String?
  banned        Boolean?
  banReason     String?
  banExpires    DateTime?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  sessions      Session[]
  accounts      Account[]
  exams         Exam[]
  categories    Category[]
}

model Session {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id           String   @id @default(uuid())
  userId       String
  providerId   String
  accountId    String
  password     String?
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Verification {
  id         String   @id @default(uuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
}

// =======================
// EXAM MODELS
// =======================

model Exam {
  id          String   @id @default(uuid())
  title       String
  description String?
  code        String   @unique
  duration    Int
  passMark    Int      @default(0)
  shuffleQuestions Boolean @default(false)

  teacherId   String?
  teacher     User?    @relation(fields: [teacherId], references: [id])

  categoryId  String?
  category    Category? @relation(fields: [categoryId], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  questions   Question[]
  attempts    Attempt[]
}

model Category {
  id        String   @id @default(uuid())
  name      String

  teacherId String
  teacher   User     @relation(fields: [teacherId], references: [id], onDelete: Cascade)

  exams     Exam[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, teacherId])
}

model Question {
  id             String         @id @default(uuid())
  idx            Int            @default(autoincrement())
  text           String
  type           QuestionType
  evaluationType EvaluationType @default(AUTO)
  points         Int            @default(1)

  examId         String
  exam           Exam           @relation(fields: [examId], references: [id], onDelete: Cascade)

  mcq            MCQQuestion?
  trueFalse      TrueFalseQuestion?
  fillBlank      FillBlankQuestion?

  answers        Answer[]
}

// =======================
// QUESTION TYPES
// =======================

// ---- MULTIPLE CHOICE ----

model MCQQuestion {
  id          String   @id @default(uuid())
  questionId  String   @unique
  question    Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  choices     Choice[]
}

model Choice {
  id       String @id @default(uuid())
  text     String
  isCorrect Boolean @default(false)

  mcqId    String
  mcq      MCQQuestion @relation(fields: [mcqId], references: [id], onDelete: Cascade)
}

// ---- TRUE / FALSE ----

model TrueFalseQuestion {
  id         String   @id @default(uuid())
  questionId String   @unique
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  correct    Boolean
}

// ---- FILL IN THE BLANK ----

model FillBlankQuestion {
  id          String   @id @default(uuid())
  questionId  String   @unique
  question    Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  answers     String[]  // accepted answers
  clue        String?   // null = normal fill blank
}

// =======================
// ATTEMPTS & ANSWERS
// =======================

model Attempt {
  id          String   @id @default(uuid())
  studentName String
  score       Int      @default(0)
  strikes     Int      @default(0)

  examId      String
  exam        Exam     @relation(fields: [examId], references: [id], onDelete: Cascade)

  startedAt   DateTime @default(now())
  finishedAt  DateTime?

  answers     Answer[]
}

model Answer {
  id          String   @id @default(uuid())

  attemptId   String
  attempt     Attempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)

  questionId  String
  question    Question @relation(fields: [questionId], references: [id])

  // AUTO-GRADABLE ANSWERS
  selectedChoiceIds String[]
  booleanAnswer     Boolean?
  textAnswer        String?
}
